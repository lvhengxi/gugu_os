# IPL启动模块
IPL是启动引导程序，BIOS的最后一个阶段，会将IP寄存器的值改为0x7c00，这是IPL引导扇区的装载地址，所以，IPL要从0x7c00开始。一共512kb内存，由0x55，0xaa结束。

IPL最后会跳到转到0xc200位置。这是asmhead.asm编译之后存在的地方。asmhead是初始化操作系统的地方，它主要的功能有几个。
1.设置屏幕状态，分辨率等等。
2.初始化中断。
3.开启A20总线，使操作系统可以读取超过1MB内存。从实模式到保护模式。并且开启c语言时代。

# 分段式内存管理系统
使用分段内存，将内存分为4KB的段，每个段都是0开始，而不需要org去不同的地方。

在32位下，段寄存器只有16位，且由于设计原因，段寄存器低三位不能使用，最多有8192个段。GDT 64kb=8192*8.


# 中断处理
IDT和GDT很类似，全程是中断向量表，表示中断发生的时候去执行什么程序。中断产生，PIC将中断信号传输给CPU，CPU直接终止当前操作，将当前寄存器保存，popad这个指令直接依次弹出寄存器。  
# 多任务
TSS内存段，每个程序都有一个，EIP寄存器，记住执行的下一条指令在哪，JMP的本质就是给EIP赋值。JMP有far和neer模式，当JMP去到的地址的GDT表示是个指令就直接执行， 如果是指向的TSS那就是跳转到别的任务进行执行。
如果给每个程序都是相同的时间，就会出现任务A疯狂缺时间，任务B一直闲置等待输入这种，我们设定一个时间，比如两个周期A都没出现任务，直接将其睡眠，直到有数据写入，有数据写入往往代表着有需要执行的任务。

# 图像界面
本来说是做出精美的画面，但是关于显卡的设置实在搞不出来，使用BIOS提供的画面功能来实现。
图层的处理。使用一个结构体shtctl来控制图层，最多可以开启256个图层，一般也够用，这个地方用了一个很粗糙的方式来进行处理，每次开启一个图层，都要在shtctl中进行注册，并且按照优先级对画面进行处理，将其写入显存当中，按照从大到小的顺序，但是会非常的慢，每次鼠标动一下，我就要处理整个画面，将其优化为只需要挪动一点点的画面。并且解决了鼠标挪出窗口外的功能，显存比实际大一点，就可以解决。


# 编译过程
1.预编译，将宏定义之类的进行展开
2.编译，生产.o，但是没有解析外部符号，紧紧解析编译后的机器指令。
3.链接，和其他目标程序进行链接，生产最终的可执行程序，连接器负责解析外部指令。并将各个目标文件中的地址信息调整为最终的运行时地址。
