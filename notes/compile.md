关于汇编的一些记录，汇编真的太难了吧，wdnmd
DB和RESB
往内存中写入数据，DB是写入一个字节的指令，RESB是占据很多格子，但并不将其赋值.

关于\$,在这个项目中，我并不想依赖作者的nask编译器，所以使用了院办的nasm编译器，两个编译器对\$的解释不同，\$的含义是当前的地址，也就是偏移量。

操作系统必须从0x7c00位置开始，这谁因为前面的地址被bios占用，历史遗留原因导致操作系统必须从这里开始。使用ORG(origin)这个指令告诉编译器，在开始执行的时候，将这些机器语言装载到内存中的具体地址。

JMP(jump)跳转到后面的地址。

16位寄存器
AX 累加寄存器
CX 计数寄存器
DX 数据寄存器
BX 基址寄存器
SP 栈指针寄存器
BP 基址指针寄存器
SI 源地址寄存器
DI 目的地址寄存器

当前面+E就变成了32位寄存器 ACDB这四个寄存器后面变成L或者H表示表示高低位

段寄存器
ES 附加段寄存器
CS 代码段寄存器
SS 栈段寄存器
DS 数据段寄存器
FS GS 没有名称

mov表示复制粘贴(我的理解)，mov AX [SI]表示从内存中取出SI位置的数据复制到AX中。

INT 表示调用BIOS的函数

JC "jump if carry" 如果进位符号为1，就跳转。

nask代码              NASM代码


JMP entry       ->   JMP SHORT entry

RESB <填充字节数>         ->   TIMES <填充字节数> DB <填充数据>

RESB 0x7dfe-$   ->   TIMES 0x1fe-($-$$) DB 0

ALIGNB 16       ->   ALIGN 16, DB 0


vim可以用%!xxd 和%!xxd -r 来查看二进制


说说为什么会有0x8000这一说：是有些操作系统会把操作系统的代码放到0x8000，这是因为BIOS读完启动扇区以后，会跳转到0x7C00启动，占用0x7C00-0x7DFF这一段（512字节），而一般bootloader还需要一个栈空间或者读磁盘的交换空间，一般是放到0x7E00-0x7FFF这512字节里，所以有些操作系统的镜像起点是0x8000。

要把Makefile中的copy改成cp

暂时留坑，并不知道edimg的操作原理，这点很烦
